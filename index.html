<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>FC26 Manager - Ultimate Data Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
:root {
--bg: #05070a; --card: #111418; --border: #30363d;
--accent: #238636; --blue: #58a6ff; --gold: #d4af37;
--silver: #bec2cb; --bronze: #cd7f32;
--text: #f8fafc; --muted: #8b949e; --danger: #da3633;
--purple: #8957e5;
}
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { margin: 0; font-family: 'Poppins', sans-serif; background: var(--bg); color: var(--text); padding-bottom: 90px; }

/* --- STYLES EXPORT PDF --- */
.pdf-export-content { background: white; color: black; padding: 40px; font-family: Arial, sans-serif; }
.pdf-header { text-align: center; border-bottom: 2px solid #1e1b4b; margin-bottom: 20px; padding-bottom: 10px; }
.pdf-season-block { margin-bottom: 30px; page-break-inside: avoid; }
.pdf-season-title { color: #1e1b4b; background: #f0f0f0; padding: 8px 15px; border-left: 5px solid #238636; margin-bottom: 10px; }
.pdf-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
.pdf-table th, .pdf-table td { border: 1px solid #ccc; padding: 8px; text-align: center; font-size: 9pt; }
.pdf-table th { background: #e9ecef; font-weight: bold; }
/* ------------------------- */

#syncNotify { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background: var(--purple); color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.7rem; font-weight: bold; z-index: 2000; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); transition: 0.3s; }

#loginOverlay, #pinOverlay { position: fixed; inset: 0; background: var(--bg); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
#pinOverlay { display: none; background: rgba(5, 7, 10, 0.98); }
.login-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 400px; margin-top: 30px; }
.user-btn { background: var(--card); border: 1px solid var(--border); color: white; padding: 20px; border-radius: 15px; cursor: pointer; text-align: center; transition: 0.3s; }
.user-btn:hover { border-color: var(--purple); transform: translateY(-5px); }
.admin-lock { border-color: var(--gold); }
.pin-input { background: #000; border: 2px solid var(--border); color: var(--gold); font-size: 2rem; width: 150px; text-align: center; border-radius: 12px; margin: 20px 0; letter-spacing: 10px; padding: 10px; }

header { background: #010409; padding: 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; position: sticky; top:0; z-index:100; }
.season-badge { background: var(--gold); color: #000; padding: 4px 12px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; }
.sync-status { font-size: 0.6rem; color: var(--accent); display: flex; align-items: center; gap: 5px; }

.ticker-wrap { background: #010409; border-bottom: 1px solid var(--border); overflow: hidden; white-space: nowrap; padding: 5px 0; }
.ticker { display: inline-block; animation: ticker 40s linear infinite; }
.ticker-item { display: inline-block; padding: 0 20px; font-size: 0.65rem; color: var(--muted); border-right: 1px solid var(--border); }
.ticker-item b { color: var(--blue); margin: 0 5px; }
@keyframes ticker { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }

nav { position: fixed; bottom: 0; left: 0; right: 0; background: #111418; display: flex; justify-content: space-around; padding: 12px 0; border-top: 1px solid var(--border); z-index: 1000; }
nav button { background: none; border: none; color: var(--muted); display: flex; flex-direction: column; align-items: center; font-size: 0.7rem; gap: 5px; cursor: pointer; }
nav button.active { color: var(--accent); }

main { padding: 15px; max-width: 600px; margin: auto; }
.card { background: var(--card); border: 1px solid var(--border); border-radius: 16px; padding: 16px; margin-bottom: 16px; position: relative; }

/* PROGRESION - FIXED SCALE VERSION */
.sparkline-box { display: flex; align-items: flex-end; gap: 3px; height: 24px; justify-content: center; overflow: hidden; }
.spark-bar { width: 5px; background: var(--border); border-radius: 1px; transition: height 0.3s; min-height: 2px; }
.spark-up { background: var(--accent) !important; }
.spark-down { background: var(--danger) !important; }

.badge-container { display: flex; gap: 5px; margin-top: 4px; flex-wrap: wrap; }
.prestige-badge { font-size: 0.55rem; padding: 2px 6px; border-radius: 4px; font-weight: bold; text-transform: uppercase; display: flex; align-items: center; gap: 3px; }
.badge-sniper { background: #fef3c7; color: #92400e; border: 1px solid #f59e0b; }
.badge-mur { background: #dcfce7; color: #166534; border: 1px solid #22c55e; }
.badge-clutch { background: #ede9fe; color: #5b21b6; border: 1px solid #8b5cf6; }
.badge-clean { background: #e0f2fe; color: #0369a1; border: 1px solid #0ea5e9; }

/* HOF STYLES */
.medal-card { display: flex; align-items: center; gap: 15px; padding: 15px; border-radius: 12px; margin-bottom: 10px; border-left: 5px solid transparent; }
.medal-gold { background: linear-gradient(90deg, #d4af3722, transparent); border-left-color: var(--gold); }
.medal-silver { background: linear-gradient(90deg, #bec2cb22, transparent); border-left-color: var(--silver); }
.medal-bronze { background: linear-gradient(90deg, #cd7f3222, transparent); border-left-color: var(--bronze); }
.hof-stat { font-size: 1.2rem; font-weight: bold; }
.hof-label { font-size: 0.65rem; color: var(--muted); text-transform: uppercase; }

.awards-scroll { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 15px; scrollbar-width: none; }
.award-card { min-width: 130px; background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; text-align: center; transition: 0.3s; }
.award-winner { font-size: 0.8rem; font-weight: bold; color: var(--gold); display: block; margin-top: 5px; }

table { width: 100%; border-collapse: collapse; }
th { color: var(--muted); font-size: 0.6rem; text-transform: uppercase; padding-bottom: 10px; }
td { padding: 12px 2px; border-bottom: 1px solid #30363d55; font-size: 0.85rem; vertical-align: middle; }
.col-player { text-align: left; padding-left: 5px; width: 35%; }
.col-center { text-align: center; }

.val-badge { background: #1e1b4b; color: var(--blue); padding: 2px 6px; border-radius: 4px; font-weight: bold; font-size: 0.7rem; }
.power-trend { font-size: 0.7rem; margin-left: 3px; }

.stat-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #ffffff05; }
.stat-label { font-size: 0.75rem; color: var(--muted); }
.stat-value { font-size: 0.85rem; font-weight: 600; }

.form-container { display: flex; gap: 4px; justify-content: center; }
.dot { width: 9px; height: 9px; border-radius: 50%; }
.win { background: var(--accent); box-shadow: 0 0 5px var(--accent); }
.loss { background: var(--danger); }
.draw { background: var(--muted); }

.duel-bar-container { height: 12px; background: #000; border-radius: 10px; margin: 15px 0; overflow: hidden; display: flex; border: 1px solid var(--border); }
.duel-bar-left { background: var(--blue); height: 100%; transition: width 0.5s ease; border-right: 2px solid #fff; }
.duel-bar-right { background: var(--purple); height: 100%; transition: width 0.5s ease; }

.tactic-badge { background: #1e1b4b; color: var(--blue); padding: 4px 10px; border-radius: 6px; font-size: 0.65rem; font-weight: bold; display: inline-block; margin-bottom: 10px; }
.tactic-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.7rem; }
.tactic-item { background: #0a0c10; padding: 8px; border-radius: 8px; border-left: 3px solid var(--purple); }

.predict-card { background: linear-gradient(135deg, #1e1b4b 0%, #111418 100%); border: 1px solid var(--purple); padding: 20px; margin-bottom:15px; }
.live-predict-card { background: linear-gradient(135deg, #0f172a 0%, #020617 100%); border: 1px solid var(--accent); padding: 15px; }

.brief-box { background: #0a0c10; border-left: 4px solid var(--gold); padding: 12px; margin-top: 10px; font-size: 0.75rem; border-radius: 4px; line-height: 1.4; }
.brief-title { color: var(--gold); font-weight: bold; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; font-size: 0.7rem; }
.brief-advice { color: var(--muted); font-style: italic; display: block; margin-top: 5px; border-top: 1px solid #333; padding-top: 5px; }

.match-card { border-bottom: 1px solid var(--border); padding: 15px 0; }
.team-row { display: flex; align-items: center; justify-content: space-between; margin: 8px 0; }
.team-select { background: #000; color: white; border: 1px solid var(--border); border-radius: 8px; padding: 6px; font-size: 0.7rem; width: 110px; }
.score-input { width: 45px; height: 40px; background: #000; border: 1px solid var(--border); color: white; text-align: center; border-radius: 8px; font-weight: bold; font-size: 1.1rem; }

.btn-primary { background: var(--accent); color: white; border: none; padding: 12px; border-radius: 12px; width: 100%; font-weight: bold; cursor: pointer; }
.btn-rotation { background: var(--purple); margin-top: 10px; }
.btn-edit { background: none; border: 1px solid var(--blue); color: var(--blue); padding: 4px 8px; border-radius: 6px; font-size: 0.6rem; cursor: pointer; }
.edit-box { background: #000; padding: 15px; border-radius: 10px; margin-top: 10px; border: 1px dashed var(--blue); text-align: center; }

#winnerModal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:2000; justify-content:center; align-items:center; text-align:center; padding: 20px; }

/* NOUVEAU STYLE COMMENTAIRE */
.match-commentary { 
    background: rgba(88, 166, 255, 0.05); 
    border: 1px solid #30363d; 
    padding: 8px 12px; 
    border-radius: 8px; 
    margin-top: 10px; 
    font-size: 0.7rem; 
    color: var(--muted); 
    font-style: italic;
    line-height: 1.3;
}
.match-commentary b { color: var(--blue); }
</style>
</head>
<body>

<div id="syncNotify"><i class="fas fa-sync-alt fa-spin"></i> Mise √† jour Live...</div>

<div id="loginOverlay">
<i class="fas fa-shield-halved" style="font-size: 3rem; color: var(--purple); margin-bottom: 10px;"></i>
<h2 style="margin:0">FC26 ELITE</h2>
<div class="login-grid">
<div class="user-btn admin-lock" onclick="checkPin()"><i class="fas fa-user-crown" style="color:var(--gold)"></i>ADMIN</div>
<div class="user-btn" onclick="login('BVI')"><i class="fas fa-user"></i>BVI</div>
<div class="user-btn" onclick="login('NAD')"><i class="fas fa-user"></i>NAD</div>
<div class="user-btn" onclick="login('WIL')"><i class="fas fa-user"></i>WIL</div>
<div class="user-btn" onclick="login('BROOK')"><i class="fas fa-user"></i>BROOK</div>
</div>
</div>

<div id="pinOverlay">
<input type="password" id="pinCode" class="pin-input" maxlength="4" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
<button class="btn-primary" onclick="validatePin()">OK</button>
</div>

<div id="winnerModal">
<div style="background: var(--card); padding: 40px; border-radius: 30px; border: 2px solid var(--gold);">
<i class="fas fa-trophy" style="font-size: 4rem; color: var(--gold); margin-bottom: 20px;"></i>
<h1 id="winnerName">-</h1>
<button class="btn-primary" onclick="closeWinner()">NOUVELLE SAISON üî•</button>
</div>
</div>

<header>
<div onclick="logout()" style="cursor:pointer"><i class="fas fa-power-off"></i> <span id="userDisplay" style="font-size:0.7rem; color:var(--muted); margin-left:5px"></span></div>
<div style="display:flex; align-items:center; gap:10px">
<div class="sync-status" id="syncStatus"><i class="fas fa-circle" style="font-size:0.5rem"></i> LIVE</div>
<div id="seasonBadge" class="season-badge">Saison 1</div>
</div>
</header>

<div id="resultTicker" class="ticker-wrap"></div>

<main id="app"></main>

<nav>
<button class="active" data-tab="dashboard"><i class="fas fa-chart-line"></i><span>Stats</span></button>
<button data-tab="analysis"><i class="fas fa-brain"></i><span>IA</span></button>
<button data-tab="matches"><i class="fas fa-gamepad"></i><span>Jouer</span></button>
<button data-tab="players"><i class="fas fa-users"></i><span>Joueurs</span></button>
<button data-tab="hof"><i class="fas fa-crown"></i><span>H.O.F</span></button>
<button data-tab="archives"><i class="fas fa-history"></i><span>Palmar√®s</span></button>
</nav>

<script>
const FB_URL = "https://fc26-e596e-default-rtdb.europe-west1.firebasedatabase.app/data.json";
const ADMIN_PIN = "1234";
const TEAMS = ["Real Madrid", "Man City", "Barcelone", "Bayern Munich", "Liverpool", "PSG", "Arsenal", "Inter Milan", "Milan AC", "Atletico", "Leverkusen", "Dortmund", "Juventus", "Naples", "Chelsea", "Aston Villa"];

let currentUser = localStorage.getItem("fc26_user") || null;
let state = { season: 1, players: [], currentDay: [], archives: [], rotationQueue: [] };
let isInteracting = false;
let duelChartInstance = null;

const notifySound = new Audio("https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3");
const qs = (s) => document.querySelector(s);
const isAdmin = () => currentUser === 'ADMIN';

async function pushData() { if (isAdmin()) { try { await fetch(FB_URL, { method: 'PUT', body: JSON.stringify(state) }); } catch (e) {} } }
async function pullData() {
if (isInteracting) return;
try {
const res = await fetch(FB_URL);
const data = await res.json();
if (data && JSON.stringify(data) !== JSON.stringify(state)) {
state = data; render(); showNotify(); qs('#seasonBadge').innerText = `SAISON ${state.season}`;
}
} catch (e) {}
}

function showNotify() { const n = qs("#syncNotify"); n.style.display = "block"; notifySound.play().catch(e => {}); setTimeout(() => { n.style.display = "none"; }, 3000); }
setInterval(pullData, 5000);

function updateTicker() {
    const ticker = qs("#resultTicker");
    if (!state.archives || state.archives.length === 0) {
        ticker.style.display = "none";
        return;
    }
    ticker.style.display = "block";
    const lastMatches = state.archives.flat().slice(-10).reverse();
    const content = lastMatches.map(m => `
        <div class="ticker-item">
            ${m.p1} <b>${m.s1}-${m.s2}</b> ${m.p2} 
        </div>
    `).join('');
    ticker.innerHTML = `<div class="ticker">${content}${content}</div>`;
}

function checkPin() { qs('#pinOverlay').style.display = 'flex'; qs('#pinCode').focus(); }
function validatePin() { if(qs('#pinCode').value === ADMIN_PIN) { qs('#pinOverlay').style.display = 'none'; login('ADMIN'); } else { alert("PIN Incorrect"); } }
function login(user) { currentUser = user; localStorage.setItem("fc26_user", user); qs('#loginOverlay').style.display = 'none'; qs('#userDisplay').innerText = user; pullData(); }
function logout() { localStorage.removeItem("fc26_user"); location.reload(); }
if(currentUser) login(currentUser);
function save() { if(isAdmin()) pushData(); render(); }

// --- CALCULS ---
function calculateValue(p) { 
    let base = 10;
    let ptsValue = (p.points || 0) * 1.5;
    let gdValue = ((p.gf || 0) - (p.ga || 0)) * 0.5;
    let csValue = (p.cs || 0) * 1.0;
    return (base + ptsValue + gdValue + csValue).toFixed(1); 
}

function getPowerRankingTrend(p) {
    const history = getForm(p.name);
    if (history.length < 2) return '‚Üí';
    const recent = history.slice(0, 3).reduce((acc, val) => acc + (val === 'win' ? 3 : (val === 'draw' ? 1 : 0)), 0) / 3;
    const allStats = getAllTimeStats()[p.name];
    const overall = allStats ? (allStats.pts / allStats.games) : 0;
    
    if (recent > overall + 0.5) return '‚Üë';
    if (recent < overall - 0.5) return '‚Üì';
    return '‚Üí';
}

function getPlayerBadges(p) {
    const badges = [];
    const stats = getAllTimeStats()[p.name];
    if(!stats || stats.games === 0) return badges;
    
    const currentMoyenne = p.gf / Math.max(1, (p.points/3 + p.ga/10)); 
    if (currentMoyenne > 3 || (stats.gf / stats.games) > 3) {
        badges.push({ class: 'badge-sniper', icon: 'fa-crosshairs', label: 'Sniper' });
    }
    
    const maxCS = Math.max(...state.players.map(pl => pl.cs || 0));
    if (p.cs > 0 && p.cs === maxCS) {
        badges.push({ class: 'badge-mur', icon: 'fa-user-shield', label: 'Muraille' });
    }

    const allMatches = state.archives ? state.archives.flat() : [];
    const clutchWins = allMatches.filter(m => {
        const isP1 = m.p1 === p.name;
        const diff = Math.abs(m.s1 - m.s2);
        return diff === 1 && ((isP1 && m.s1 > m.s2) || (!isP1 && m.s2 > m.s1));
    }).length;
    if (clutchWins >= 3) {
        badges.push({ class: 'badge-clutch', icon: 'fa-bolt', label: 'Clutch' });
    }
    return badges;
}

function getProgressionData(playerName) {
    if(!state.archives || state.archives.length < 1) return [40, 40, 40];
    const history = [];
    const last3Days = state.archives.slice(-3);
    
    last3Days.forEach(day => {
        let pts = 0;
        day.forEach(m => {
            if(m.p1 === playerName) pts += (m.s1 > m.s2 ? 3 : (m.s1 === m.s2 ? 1 : 0));
            if(m.p2 === playerName) pts += (m.s2 > m.s1 ? 3 : (m.s1 === m.s2 ? 1 : 0));
        });
        let heightPercent = Math.min(100, Math.max(10, (pts / 9) * 100));
        history.push(heightPercent);
    });
    while(history.length < 3) history.unshift(30);
    return history;
}

function getStreak(playerName) {
    const allMatches = state.archives ? state.archives.flat() : [];
    const currentMatches = state.currentDay ? state.currentDay.filter(m => m.done) : [];
    const totalHistory = [...allMatches, ...currentMatches]
        .filter(m => m.p1 === playerName || m.p2 === playerName)
        .reverse();

    if (totalHistory.length === 0) return { count: 0, type: 'none' };
    let count = 0;
    let type = null;
    for (let i = 0; i < totalHistory.length; i++) {
        const m = totalHistory[i];
        const isP1 = m.p1 === playerName;
        const currentResult = m.s1 === m.s2 ? 'draw' : 
                             ((isP1 && m.s1 > m.s2) || (!isP1 && m.s2 > m.s1) ? 'win' : 'loss');
        if (i === 0) {
            type = currentResult;
            count = 1;
        } else {
            if (currentResult === type) count++;
            else break;
        }
    }
    return { count, type };
}

function getSeasonWinner(sNum) {
    if(!state.archives) return "Inconnu";
    let pts = {};
    const matches = state.archives.flat().filter(m => m.seasonRef == sNum);
    if(matches.length === 0) return "-";
    matches.forEach(m => {
        if(!pts[m.p1]) pts[m.p1] = 0;
        if(!pts[m.p2]) pts[m.p2] = 0;
        if(m.s1 > m.s2) pts[m.p1] += 3;
        else if(m.s2 > m.s1) pts[m.p2] += 3;
        else { pts[m.p1] += 1; pts[m.p2] += 1; }
    });
    return Object.keys(pts).reduce((a, b) => pts[a] > pts[b] ? a : b);
}

function getHOFStats() {
    const medals = {}; 
    const allTimeStats = getAllTimeStats();
    const players = state.players.map(p => p.name);
    players.forEach(p => medals[p] = { gold: 0, silver: 0, bronze: 0, goals: allTimeStats[p]?.gf || 0, cs: allTimeStats[p]?.cs || 0, seasons: new Set() });

    if(state.archives) {
        const seasons = [...new Set(state.archives.flat().map(m => m.seasonRef))];
        seasons.forEach(s => {
            const matches = state.archives.flat().filter(m => m.seasonRef == s);
            let pts = {};
            matches.forEach(m => {
                if(!pts[m.p1]) pts[m.p1] = 0; if(!pts[m.p2]) pts[m.p2] = 0;
                if(m.s1 > m.s2) pts[m.p1] += 3; else if(m.s2 > m.s1) pts[m.p2] += 3; else { pts[m.p1]++; pts[m.p2]++; }
                if(medals[m.p1]) medals[m.p1].seasons.add(s);
                if(medals[m.p2]) medals[m.p2].seasons.add(s);
            });
            const sorted = Object.keys(pts).sort((a,b) => pts[b] - pts[a]);
            if(sorted[0] && medals[sorted[0]]) medals[sorted[0]].gold++;
            if(sorted[1] && medals[sorted[1]]) medals[sorted[1]].silver++;
            if(sorted[2] && medals[sorted[2]]) medals[sorted[2]].bronze++;
        });
    }

    let highestScore = { p1: "-", p2: "-", s1: 0, s2: 0, total: 0 };
    const allMatches = state.archives ? state.archives.flat() : [];
    allMatches.forEach(m => {
        if((m.s1 + m.s2) > highestScore.total) {
            highestScore = { ...m, total: m.s1 + m.s2 };
        }
    });
    return { medals, highestScore };
}

function getGoat() {
    if(!state.archives || state.archives.length === 0) return { name: "-", titles: 0 };
    const titles = {};
    const seasons = [...new Set(state.archives.flat().map(m => m.seasonRef))];
    seasons.forEach(s => {
        const winner = getSeasonWinner(s);
        if(winner !== "-" && winner !== "Inconnu") titles[winner] = (titles[winner] || 0) + 1;
    });
    const winnerName = Object.keys(titles).reduce((a, b) => titles[a] > titles[b] ? a : b, "-");
    return { name: winnerName, titles: titles[winnerName] || 0 };
}

function getAllTimeStats() {
let stats = {}; if(!state.archives) return stats;
state.archives.flat().forEach(m => {
if(!stats[m.p1]) stats[m.p1] = { gf:0, ga:0, pts:0, cs:0, games:0 };
if(!stats[m.p2]) stats[m.p2] = { gf:0, ga:0, pts:0, cs:0, games:0 };
stats[m.p1].gf += m.s1; stats[m.p1].ga += m.s2; stats[m.p1].games++;
stats[m.p2].gf += m.s2; stats[m.p2].ga += m.s1; stats[m.p2].games++;
if(m.s2 === 0) stats[m.p1].cs++;
if(m.s1 === 0) stats[m.p2].cs++;
if(m.s1 > m.s2) stats[m.p1].pts += 3; else if(m.s2 > m.s1) stats[m.p2].pts += 3; else { stats[m.p1].pts++; stats[m.p2].pts++; }
});
return stats;
}

function getLivePrediction() {
if(!state.players || state.players.length === 0) return null;
let scores = state.players.map(p => {
let power = p.points + ((p.gf - p.ga) * 0.5) + (p.cs * 0.5);
return { name: p.name, power: power };
});
scores.sort((a,b) => b.power - a.power);
let totalPower = scores.reduce((acc, curr) => acc + Math.max(0.1, curr.power), 0);
let top = scores[0];
let proba = Math.round((Math.max(0.1, top.power) / (totalPower || 1)) * 100);
return { name: top.name, proba: proba };
}

function getSeasonRecord() {
let record = { name: "-", goals: 0, season: 0 }; if(!state.archives) return record;
const seasons = {};
state.archives.flat().forEach(m => {
const key1 = `S${m.seasonRef}_${m.p1}`; const key2 = `S${m.seasonRef}_${m.p2}`;
seasons[key1] = (seasons[key1] || 0) + m.s1; seasons[key2] = (seasons[key2] || 0) + m.s2;
});
Object.keys(seasons).forEach(k => { if(seasons[k] > record.goals) { record.goals = seasons[k]; record.name = k.split('_')[1]; record.season = k.split('_')[0]; } });
return record;
}
function getForm(name) {
const history = []; const allMatches = state.archives ? state.archives.flat() : [];
[...allMatches].reverse().forEach(m => {
if((m.p1 === name || m.p2 === name) && history.length < 5) {
const win = (m.p1 === name) ? m.s1 > m.s2 : m.s2 > m.s1;
const draw = m.s1 === m.s2;
history.push(win ? 'win' : (draw ? 'draw' : 'loss'));
}
});
return history;
}
function getPrediction() {
const allTime = getAllTimeStats(); if (Object.keys(allTime).length === 0) return { name: "N/A", proba: 0 };
let best = Object.keys(allTime).reduce((a, b) => (allTime[a]?.pts||0) > (allTime[b]?.pts||0) ? a : b);
let total = Object.values(allTime).reduce((a, b) => a + (b.pts||0), 0);
return { name: best, proba: Math.round(((allTime[best]?.pts||0)/(total||1))*100) };
}
function getTactic(playerName) {
const stats = getAllTimeStats()[playerName] || {gf:0, ga:0, games:1};
const avgGf = stats.gf / stats.games; const avgGa = stats.ga / stats.games;
if(avgGf > 2.5) return { form: "4-3-3 OFFENSIF", style: "Construction Rapide", def: "Pressing Constant", width: "65 / 70", role: "Faux 9 / Ailiers Int√©rieurs" };
if(avgGa < 1.5) return { form: "5-2-1-2", style: "Contre-Attaque", def: "Reculer", width: "40 / 30", role: "Piston Offensif" };
return { form: "4-2-3-1 (2)", style: "√âquilibr√©", def: "√âquilibr√©", width: "50 / 50", role: "MOC Libre / Pivot" };
}

function getMatchBriefing(p1Name, p2Name) {
    const allMatches = state.archives ? state.archives.flat() : [];
    const stats = getAllTimeStats();
    let headToHead = { p1Wins: 0, p2Wins: 0, draws: 0, p1Goals: 0, p2Goals: 0 };
    allMatches.forEach(m => {
        if((m.p1 === p1Name && m.p2 === p2Name) || (m.p1 === p2Name && m.p2 === p1Name)) {
            const p1IsM1 = m.p1 === p1Name;
            if(m.s1 === m.s2) headToHead.draws++;
            else if((p1IsM1 && m.s1 > m.s2) || (!p1IsM1 && m.s2 > m.s1)) headToHead.p1Wins++;
            else headToHead.p2Wins++;
            headToHead.p1Goals += p1IsM1 ? m.s1 : m.s2;
            headToHead.p2Goals += p1IsM1 ? m.s2 : m.s1;
        }
    });
    const totalGames = headToHead.p1Wins + headToHead.p2Wins + headToHead.draws;
    const p1Form = getForm(p1Name);
    const p2Form = getForm(p2Name);
    let analysis = "";
    if(totalGames === 0) analysis = "Premier duel historique ! ";
    else {
        const leader = headToHead.p1Wins > headToHead.p2Wins ? p1Name : (headToHead.p2Wins > headToHead.p1Wins ? p2Name : null);
        analysis = leader ? `**${leader}** a l'avantage psychologique (${Math.max(headToHead.p1Wins, headToHead.p2Wins)} victoires). ` : "√âgalit√© parfaite sur leurs duels pass√©s. ";
    }
    if(p1Form[0] === 'win' && p1Form[1] === 'win') analysis += `**${p1Name}** est sur une s√©rie de feu. `;
    if(p2Form[0] === 'loss' && p2Form[1] === 'loss') analysis += `Attention, **${p2Name}** semble en plein doute. `;
    let advice = "IA : ";
    const avgGaP2 = (stats[p2Name]?.ga / stats[p2Name]?.games) || 0;
    if(avgGaP2 > 2.5) advice += `La d√©fense de **${p2Name}** prend l'eau (${avgGaP2.toFixed(1)} buts/m), **${p1Name}** doit tout miser sur l'attaque.`;
    else if(totalGames > 0 && headToHead.p1Goals / totalGames > 2) advice += `**${p1Name}** sait comment marquer face √† ce bloc, patience et contres rapides recommand√©s.`;
    else advice += "Match ferm√© en vue. Le premier but sera probablement d√©cisif.";
    return { analysis, advice };
}

// --- FONCTION COMMENTAIRE AUTOMATIQUE ENRICHIE ---
function generateMatchCommentary(m) {
    const winner = m.s1 > m.s2 ? m.p1 : (m.s2 > m.s1 ? m.p2 : null);
    const loser = winner === m.p1 ? m.p2 : m.p1;
    const diff = Math.abs(m.s1 - m.s2);
    const total = m.s1 + m.s2;
    const statsAllTime = getAllTimeStats();
    
    let base = "";
    let specialEvent = "";

    if (winner) {
        const sortedScorers = Object.entries(statsAllTime).sort((a,b) => b[1].gf - a[1].gf);
        if (sortedScorers[0] && winner === sortedScorers[0][0]) {
            specialEvent = ` <br>‚≠ê <b>HISTORIQUE :</b> <b>${winner}</b> confirme sa place de meilleur buteur de l'histoire !`;
        }

        if ((m.s1 === 0 || m.s2 === 0)) {
            const currentCS = statsAllTime[winner]?.cs || 0;
            if (currentCS % 5 === 0 && currentCS > 0) {
                specialEvent = ` <br>üõ°Ô∏è <b>LE MUR :</b> <b>${winner}</b> vient de signer sa ${currentCS}√®me Clean Sheet all-time !`;
            }
        }

        const streak = getStreak(winner);
        if (streak.count >= 3 && streak.type === 'win') {
            specialEvent = ` <br>üî• <b>S√âRIE :</b> Personne n'arr√™te <b>${winner}</b> ! ${streak.count}√®me victoire cons√©cutive.`;
        }
    }

    const winPhrases = [
        `Victoire imp√©riale de <b>${winner}</b> qui n'a laiss√© aucune chance √† son adversaire.`,
        `<b>${winner}</b> dicte sa loi aujourd'hui ! Un succ√®s pr√©cieux.`,
        `Quel r√©alisme de <b>${winner}</b> ! Le plan de jeu a fonctionn√© √† merveille.`
    ];
    const tightPhrases = [
        `<b>${winner}</b> l'emporte de justesse au terme d'un duel tactique intense.`,
        `Match sous haute tension ! <b>${winner}</b> arrache les 3 points sur le fil.`,
        `Cruel pour <b>${loser}</b>, mais c'est <b>${winner}</b> qui sort vainqueur de ce combat.`
    ];
    const stompPhrases = [
        `D√©monstration de force ! <b>${winner}</b> a litt√©ralement humili√© <b>${loser}</b>.`,
        `Festival offensif ! <b>${winner}</b> √©tait sur une autre plan√®te.`,
        `<b>${loser}</b> va devoir oublier ce cauchemar au plus vite...`
    ];
    const drawPhrases = [
        `Un nul qui n'arrange personne. <b>${m.p1}</b> et <b>${m.p2}</b> se quittent dos √† dos.`,
        `√âgalit√© parfaite. Les deux managers ont neutralis√© leurs forces.`,
        `Spectacle d√©cevant ou d√©fense de fer ? Le score reste de parit√©.`
    ];

    if (winner) {
        if (diff >= 4) base = stompPhrases[Math.floor(Math.random() * stompPhrases.length)];
        else if (diff === 1) base = tightPhrases[Math.floor(Math.random() * tightPhrases.length)];
        else base = winPhrases[Math.floor(Math.random() * winPhrases.length)];
        
        if ((m.s1 === 0 || m.s2 === 0) && !specialEvent.includes("MUR")) {
            base += " La d√©fense a √©t√© h√©ro√Øque, aucun but encaiss√© !";
        }
    } else {
        if (total >= 4) base = "Un match nul spectaculaire ! Les attaques ont pris le pas sur les d√©fenses.";
        else base = drawPhrases[Math.floor(Math.random() * drawPhrases.length)];
    }
    
    return base + specialEvent;
}

// --- NOUVELLE FONCTION EXPORT PDF STRUCTUR√â ---
function exportFullHistoryPDF() {
    const container = document.createElement('div');
    container.className = 'pdf-export-content';
    container.innerHTML = `<div class="pdf-header"><h1>RAPPORT HISTORIQUE - FC26 ELITE</h1><p>Date d'export : ${new Date().toLocaleDateString()}</p></div>`;

    if(!state.archives || state.archives.length === 0) {
        container.innerHTML += "<p style='text-align:center'>Aucune donn√©e archiv√©e.</p>";
    } else {
        const grouped = {};
        state.archives.flat().forEach(m => {
            if(!grouped[m.seasonRef]) grouped[m.seasonRef] = [];
            grouped[m.seasonRef].push(m);
        });

        Object.keys(grouped).sort((a,b)=>b-a).forEach(sNum => {
            const winner = getSeasonWinner(sNum);
            let html = `<div class="pdf-season-block">
                <h2 class="pdf-season-title">SAISON ${sNum} ‚Äî Vainqueur : ${winner} üèÜ</h2>
                <table class="pdf-table">
                    <thead><tr><th>Match</th><th>Score</th><th>√âquipes jou√©es</th><th>Date</th></tr></thead>
                    <tbody>`;
            grouped[sNum].forEach(m => {
                html += `<tr>
                    <td>${m.p1} vs ${m.p2}</td>
                    <td style="font-weight:bold">${m.s1} - ${m.s2}</td>
                    <td>${m.team1} / ${m.team2}</td>
                    <td>${m.date || '-'}</td>
                </tr>`;
            });
            html += `</tbody></table></div>`;
            container.innerHTML += html;
        });
    }

    const opt = { margin: 10, filename: `FC26_Historique_Complet.pdf`, html2canvas: { scale: 2 }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' } };
    html2pdf().from(container).set(opt).save();
}

function render() {
updateTicker();
const tab = qs("nav button.active").dataset.tab;
const app = qs("#app"); app.innerHTML = "";

if (tab === "dashboard") {
    const sorted = [...state.players].sort((a,b) => b.points - a.points || (b.gf-b.ga)-(a.gf-a.ga));
    const pichichi = [...state.players].sort((a,b) => b.gf - a.gf)[0];
    const defense = [...state.players].sort((a,b) => (a.ga/Math.max(1,a.points)) - (b.ga/Math.max(1,b.points)))[0];
    const topCS = [...state.players].sort((a,b) => (b.cs || 0) - (a.cs || 0))[0];
    const topVal = sorted.length ? [...state.players].sort((a,b) => calculateValue(b) - calculateValue(a))[0] : null;

    app.innerHTML = `
    <div class="awards-scroll">
        <div class="award-card"><i class="fas fa-fire" style="color:#ff4500"></i><br>Pichichi<span class="award-winner">${pichichi?.name || '-'}</span></div>
        <div class="award-card"><i class="fas fa-shield-alt" style="color:var(--blue)"></i><br>D√©fense<span class="award-winner">${defense?.name || '-'}</span></div>
        <div class="award-card"><i class="fas fa-hand-sparkles" style="color:var(--gold)"></i><br>Gants d'Or<span class="award-winner">${topCS?.name || '-'}</span></div>
    </div>

    <div class="card">
        <table>
            <thead><tr><th class="col-player">Manager</th><th class="col-center">PTS</th><th class="col-center">V/N/D</th><th class="col-center">DIF</th><th class="col-center">VAL</th></tr></thead>
            <tbody>
                ${sorted.map(p => {
                    const prog = getProgressionData(p.name);
                    const badges = getPlayerBadges(p);
                    const streak = getStreak(p.name);
                    return `
                    <tr>
                        <td class="col-player">
                            <div style="font-weight:600">${p.name} <span class="power-trend">${getPowerRankingTrend(p)}</span></div>
                            <div class="sparkline-box">
                                ${prog.map(h => `<div class="spark-bar" style="height:${h}%"></div>`).join('')}
                            </div>
                            <div class="badge-container">
                                ${badges.map(b => `<span class="prestige-badge ${b.class}"><i class="fas ${b.icon}"></i> ${b.label}</span>`).join('')}
                                ${streak.count >= 2 ? `<span class="prestige-badge" style="background:#fef2f2; color:#b91c1c; border:1px solid #f87171">üî• ${streak.count}</span>` : ''}
                            </div>
                        </td>
                        <td class="col-center" style="font-size:1.1rem; font-weight:700">${p.points}</td>
                        <td class="col-center" style="font-size:0.7rem; color:var(--muted)">${p.v}/${p.n}/${p.d}</td>
                        <td class="col-center ${p.gf-p.ga >= 0 ? 'spark-up' : 'spark-down'}" style="background:none; font-weight:bold">${p.gf-p.ga > 0 ? '+' : ''}${p.gf-p.ga}</td>
                        <td class="col-center"><span class="val-badge">${calculateValue(p)}</span></td>
                    </tr>`;
                }).join('')}
            </tbody>
        </table>
    </div>
    `;
}

if (tab === "analysis") {
    const live = getLivePrediction();
    const record = getSeasonRecord();
    const goat = getGoat();
    const lastMatch = state.archives && state.archives.length > 0 ? state.archives.flat().slice(-1)[0] : null;

    app.innerHTML = `
    <div class="card predict-card">
        <div style="font-size:0.6rem; text-transform:uppercase; letter-spacing:1px; margin-bottom:10px">IA - Probabilit√© de Titre</div>
        <div style="display:flex; justify-content:space-between; align-items:flex-end">
            <div>
                <div style="font-size:2rem; font-weight:bold; color:var(--gold)">${live?.name || 'N/A'}</div>
                <div style="font-size:0.8rem; opacity:0.8">${live?.proba || 0}% de chances de gagner la saison</div>
            </div>
            <i class="fas fa-brain" style="font-size:3rem; opacity:0.2"></i>
        </div>
    </div>

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:15px">
        <div class="card" style="margin:0; padding:12px">
            <div style="font-size:0.55rem; color:var(--muted)">RECORD BUTS / SAISON</div>
            <div style="font-size:0.9rem; font-weight:bold">${record.name} (${record.goals})</div>
            <div style="font-size:0.6rem; color:var(--gold)">Saison ${record.season}</div>
        </div>
        <div class="card" style="margin:0; padding:12px">
            <div style="font-size:0.55rem; color:var(--muted)">L√âGENDE ACTUELLE</div>
            <div style="font-size:0.9rem; font-weight:bold">${goat.name}</div>
            <div style="font-size:0.6rem; color:var(--gold)">${goat.titles} Titres</div>
        </div>
    </div>

    ${lastMatch ? `
    <div class="card">
        <h3 style="margin-top:0; font-size:0.8rem"><i class="fas fa-microchip"></i> ANALYSE DERNIER MATCH</h3>
        <div style="font-size:0.75rem; color:var(--muted)">${lastMatch.p1} vs ${lastMatch.p2} (${lastMatch.s1}-${lastMatch.s2})</div>
        <div class="match-commentary">${generateMatchCommentary(lastMatch)}</div>
    </div>
    ` : ''}

    <div class="card">
        <h3 style="margin-top:0; font-size:0.8rem"><i class="fas fa-chess"></i> CONSEILS TACTIQUES IA</h3>
        ${state.players.map(p => {
            const t = getTactic(p.name);
            return `
            <div style="margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid #ffffff05">
                <div style="font-weight:bold; font-size:0.75rem; color:var(--blue); margin-bottom:5px">${p.name}</div>
                <div class="tactic-badge">${t.form}</div>
                <div class="tactic-grid">
                    <div class="tactic-item"><b>STYLE:</b> ${t.style}</div>
                    <div class="tactic-item"><b>DEF:</b> ${t.def}</div>
                    <div class="tactic-item"><b>LARGEUR:</b> ${t.width}</div>
                    <div class="tactic-item"><b>CONSIGNE:</b> ${t.role}</div>
                </div>
            </div>`;
        }).join('')}
    </div>
    `;
}

if (tab === "matches") {
    if (!isAdmin()) {
        app.innerHTML = `<div class="card" style="text-align:center; padding:40px">
            <i class="fas fa-lock" style="font-size:3rem; color:var(--muted); margin-bottom:20px"></i>
            <p>Acc√®s r√©serv√© √† l'administrateur pour enregistrer les scores.</p>
        </div>`;
    } else {
        app.innerHTML = `
        <div class="card">
            <h3 style="margin-top:0">MATCHS DU JOUR</h3>
            ${state.currentDay.map((m, idx) => {
                if(m.done) return '';
                const brief = getMatchBriefing(m.p1, m.p2);
                
                // MODIF : On v√©rifie si c'est un nul pour afficher les d√©s
                const isDraw = (m.s1 !== "" && m.s2 !== "" && parseInt(m.s1) === parseInt(m.s2));

                return `
                <div class="match-card">
                    <div class="team-row">
                        <div style="text-align:left">
                            <div style="font-weight:bold; font-size:0.9rem">${m.p1}</div>
                            <select class="team-select" onchange="state.currentDay[${idx}].team1 = this.value">
                                <option>Equipe...</option>
                                ${TEAMS.map(t => `<option ${m.team1 === t ? 'selected' : ''} value="${t}">${t}</option>`).join('')}
                            </select>
                        </div>
                        <input type="number" class="score-input" value="${m.s1}" onchange="state.currentDay[${idx}].s1 = this.value; render()">
                    </div>
                    
                    <div style="text-align:center; color:var(--muted); font-size:0.7rem; margin:5px 0">VS</div>
                    
                    <div class="team-row">
                        <div style="text-align:left">
                            <div style="font-weight:bold; font-size:0.9rem">${m.p2}</div>
                            <select class="team-select" onchange="state.currentDay[${idx}].team2 = this.value">
                                <option>Equipe...</option>
                                ${TEAMS.map(t => `<option ${m.team2 === t ? 'selected' : ''} value="${t}">${t}</option>`).join('')}
                            </select>
                        </div>
                        <input type="number" class="score-input" value="${m.s2}" onchange="state.currentDay[${idx}].s2 = this.value; render()">
                    </div>

                    ${isDraw ? `
                    <div style="background:#1e1b4b; padding:10px; border-radius:10px; margin:10px 0; border:1px solid var(--gold); text-align:center">
                        <div style="font-size:0.6rem; color:var(--gold); font-weight:bold; margin-bottom:8px">MATCH NUL : LANCER DE D√âS</div>
                        <div style="display:flex; justify-content:center; align-items:center; gap:10px">
                            <input type="number" placeholder="D√© ${m.p1}" class="score-input" style="width:60px; border-color:var(--gold)" 
                                   onchange="state.currentDay[${idx}].d1 = parseInt(this.value)" value="${m.d1 || ''}">
                            <i class="fas fa-dice" style="color:var(--gold)"></i>
                            <input type="number" placeholder="D√© ${m.p2}" class="score-input" style="width:60px; border-color:var(--gold)" 
                                   onchange="state.currentDay[${idx}].d2 = parseInt(this.value)" value="${m.d2 || ''}">
                        </div>
                    </div>
                    ` : ''}

                    <div class="brief-box">
                        <div class="brief-title"><i class="fas fa-bolt"></i> BRIEFING</div>
                        <div style="opacity:0.9">${brief.analysis}</div>
                        <div class="brief-advice">${brief.advice}</div>
                    </div>

                    <button class="btn-primary" onclick="validateMatch(${idx})" style="margin-top:15px">VALIDER LE MATCH</button>
                </div>`;
            }).join('')}
            
            <button class="btn-primary btn-rotation" onclick="rotateDay()">NOUVELLE ROTATION DES MATCHS</button>
        </div>

        <div class="card" style="border-style: dashed; opacity: 0.6">
             <h4 style="margin:0 0 10px 0; font-size:0.7rem"><i class="fas fa-tools"></i> ZONE ADMIN</h4>
             <button class="btn-primary" style="background:var(--danger); font-size:0.7rem; padding:8px" onclick="if(confirm('Finir la saison et archiver ?')) finishSeason()">FINIR LA SAISON</button>
        </div>`;
    }
}

if (tab === "players") {
    app.innerHTML = `<div class="card"><h3>GESTION DES MANAGERS</h3>
    ${state.players.map((p, idx) => `
        <div class="stat-row">
            <span class="stat-label">${p.name}</span>
            <div style="display:flex; gap:5px; align-items:center">
                ${isAdmin() ? `<button class="btn-edit" onclick="editPlayerName(${idx})">EDIT</button>` : ''}
                <span class="val-badge">${calculateValue(p)} VAL</span>
            </div>
        </div>
    `).join('')}
    ${isAdmin() ? `<button class="btn-primary" style="margin-top:15px" onclick="addPlayer()">+ AJOUTER MANAGER</button>` : ''}
    </div>`;
}

if (tab === "hof") {
    const { medals, highestScore } = getHOFStats();
    const sortedMedals = Object.entries(medals).sort((a,b) => b[1].gold - a[1].gold || b[1].silver - a[1].silver);

    app.innerHTML = `
    <div class="card" style="background: linear-gradient(135deg, #1a1a1a 0%, #000 100%); border-color: var(--gold);">
        <h3 style="color:var(--gold); text-align:center; margin-top:0"><i class="fas fa-trophy"></i> MUR DES L√âGENDES</h3>
        ${sortedMedals.map(([name, data]) => `
            <div class="medal-card ${data.gold > 0 ? 'medal-gold' : (data.silver > 0 ? 'medal-silver' : 'medal-bronze')}">
                <div style="flex:1">
                    <div style="font-weight:bold; font-size:1rem">${name}</div>
                    <div style="font-size:0.6rem; color:var(--muted)">Saisons jou√©es: ${data.seasons.size}</div>
                </div>
                <div style="display:flex; gap:15px; text-align:center">
                    <div><div class="hof-stat" style="color:var(--gold)">${data.gold}</div><div class="hof-label">Or</div></div>
                    <div><div class="hof-stat" style="color:var(--silver)">${data.silver}</div><div class="hof-label">Arg</div></div>
                    <div><div class="hof-stat" style="color:var(--bronze)">${data.bronze}</div><div class="hof-label">Bro</div></div>
                </div>
            </div>
        `).join('')}
    </div>

    <div class="card">
        <h3 style="margin-top:0; font-size:0.8rem"><i class="fas fa-star"></i> RECORDS HISTORIQUES</h3>
        <div class="stat-row">
            <span class="stat-label">Match le plus prolifique</span>
            <span class="stat-value" style="font-size:0.7rem">${highestScore.p1} ${highestScore.s1}-${highestScore.s2} ${highestScore.p2} (${highestScore.total} buts)</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Meilleure attaque all-time</span>
            <span class="stat-value">${Object.entries(medals).sort((a,b) => b[1].goals - a[1].goals)[0][0]} (${Object.entries(medals).sort((a,b) => b[1].goals - a[1].goals)[0][1].goals} buts)</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Meilleur gardien all-time</span>
            <span class="stat-value">${Object.entries(medals).sort((a,b) => b[1].cs - a[1].cs)[0][0]} (${Object.entries(medals).sort((a,b) => b[1].cs - a[1].cs)[0][1].cs} Clean Sheets)</span>
        </div>
    </div>
    `;
}

if (tab === "archives") {
    app.innerHTML = `
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px">
        <h3 style="margin:0">PALMAR√àS</h3>
        <button class="btn-primary" style="width:auto; padding:8px 15px; font-size:0.7rem; background:var(--purple)" onclick="exportFullHistoryPDF()">
            <i class="fas fa-file-pdf"></i> EXPORT COMPLET
        </button>
    </div>
    ${state.archives && state.archives.length > 0 ? 
        [...state.archives].reverse().map((day, dIdx) => `
        <div class="card">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:5px">
                <span style="font-size:0.7rem; font-weight:bold; color:var(--gold)">JOURN√âE ${state.archives.length - dIdx}</span>
                <span style="font-size:0.6rem; color:var(--muted)">Saison ${day[0].seasonRef}</span>
            </div>
            ${day.map(m => `
                <div style="display:flex; justify-content:space-between; font-size:0.8rem; padding:5px 0">
                    <span style="width:35%">${m.p1}</span>
                    <span style="width:30%; text-align:center; font-weight:bold; color:var(--blue)">${m.s1} - ${m.s2}</span>
                    <span style="width:35%; text-align:right">${m.p2}</span>
                </div>
            `).join('')}
        </div>
    `).join('') : '<div class="card">Aucun historique disponible</div>'}`;
}

qs("nav").querySelectorAll("button").forEach(b => {
    b.onclick = () => {
        qs("nav button.active").classList.remove("active");
        b.classList.add("active");
        render();
    };
});
}

function rotateDay() {
    if(!isAdmin()) return;
    if(state.rotationQueue.length < 2) {
        state.rotationQueue = state.players.map(p => p.name).sort(() => Math.random() - 0.5);
    }
    const newDay = [];
    const players = [...state.rotationQueue];
    while(players.length >= 2) {
        newDay.push({ p1: players.shift(), p2: players.shift(), s1: "", s2: "", team1: "", team2: "", done: false, seasonRef: state.season, date: new Date().toLocaleDateString() });
    }
    state.rotationQueue = players;
    state.currentDay = newDay;
    save();
}

function validateMatch(idx) {
    const m = state.currentDay[idx];
    if(m.s1 === "" || m.s2 === "") return alert("Scores incomplets");

    // MODIF : S√©curit√© pour le match nul
    const s1 = parseInt(m.s1);
    const s2 = parseInt(m.s2);
    if(s1 === s2) {
        if(!m.d1 || !m.d2) return alert("Veuillez entrer les r√©sultats des d√©s pour d√©partager le gagnant.");
        if(m.d1 === m.d2) return alert("Les d√©s ne peuvent pas √™tre √©gaux.");
    }

    const p1 = state.players.find(p => p.name === m.p1);
    const p2 = state.players.find(p => p.name === m.p2);

    p1.gf += s1; p1.ga += s2;
    p2.gf += s2; p2.ga += s1;

    if(s1 > s2) { p1.points += 3; p1.v++; p2.d++; }
    else if(s2 > s1) { p2.points += 3; p2.v++; p1.d++; }
    else { p1.points += 1; p2.points += 1; p1.n++; p2.n++; }
    
    if(s2 === 0) p1.cs = (p1.cs || 0) + 1;
    if(s1 === 0) p2.cs = (p2.cs || 0) + 1;

    m.done = true;
    if(state.currentDay.every(match => match.done)) {
        state.archives.push([...state.currentDay]);
    }
    save();
}

function finishSeason() {
    const winner = getSeasonWinner(state.season);
    qs('#winnerName').innerText = `${winner} CHAMPION ! üèÜ`;
    qs('#winnerModal').style.display = 'flex';
}

function closeWinner() {
    state.season++;
    state.players.forEach(p => { p.points = 0; p.v = 0; p.n = 0; p.d = 0; p.gf = 0; p.ga = 0; p.cs = 0; });
    state.currentDay = [];
    state.rotationQueue = [];
    qs('#winnerModal').style.display = 'none';
    save();
}

function addPlayer() {
    const name = prompt("Nom du manager:");
    if(name) {
        state.players.push({ name, points: 0, v:0, n:0, d:0, gf:0, ga:0, cs:0 });
        save();
    }
}

function editPlayerName(idx) {
    const newName = prompt("Nouveau nom:", state.players[idx].name);
    if(newName) {
        const oldName = state.players[idx].name;
        state.players[idx].name = newName;
        state.archives.flat().forEach(m => {
            if(m.p1 === oldName) m.p1 = newName;
            if(m.p2 === oldName) m.p2 = newName;
        });
        save();
    }
}

if(state.players.length === 0 && isAdmin()) {
    ["BVI", "NAD", "WIL", "BROOK"].forEach(n => state.players.push({ name: n, points: 0, v:0, n:0, d:0, gf:0, ga:0, cs:0 }));
    save();
}

render();
</script>
</body>
</html>
